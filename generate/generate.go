// Copyright 2019 Daniel Harrison. All Rights Reserved.

package generate

import (
	"strings"
	"unicode"
)

// Generate returns the codegen part of the requested zeropb messages.
func Generate(req *CodeGeneratorRequest) (*CodeGeneratorResponse, error) {
	filesToGenerate := map[string]struct{}{}
	for _, f := range req.FileToGenerate {
		filesToGenerate[f] = struct{}{}
	}
	files := make([]*CodeGeneratorResponse_File, 0, len(filesToGenerate))
	for _, fileReq := range req.ProtoFile {
		if fileReq == nil {
			continue
		}
		if _, ok := filesToGenerate[fileReq.GetName()]; !ok {
			continue
		}
		fileRes, err := generateFile(fileReq)
		if err != nil {
			return nil, err
		}
		files = append(files, fileRes)
	}
	res := &CodeGeneratorResponse{File: files}
	return res, nil
}

func generateFile(req *FileDescriptorProto) (*CodeGeneratorResponse_File, error) {
	var buf strings.Builder
	st := NewStringTree(&buf, `  `)
	var indent StringTreeIndent
	st.Write(indent, "// Code generated by protoc-gen-zeropb. DO NOT EDIT.\n\n")
	// TODO(dan): Use the go package if it's set.
	st.Write(indent, "package ", req.GetPackage(), "\n\n")
	st.Write(indent, `import "github.com/danhhz/zeropb"`, "\n\n")

	for _, m := range req.MessageType {
		if m == nil {
			continue
		}
		st.Write(indent, "type ", m.GetName(), " struct {\n")
		st.Write(indent.Next(), "buf []byte\n")
		st.Write(indent.Next(), "offsets zeropb.FastIntMap\n")
		st.Write(indent, "}\n\n")

		st.Write(indent, "func (m *", m.GetName(), ") Decode(buf []byte) error{\n")
		st.Write(indent.Next(), "m.buf = buf\n")
		st.Write(indent.Next(), "return zeropb.Decode(m.buf, &m.offsets)\n")
		st.Write(indent, "}\n\n")

		for _, f := range m.Field {
			if f == nil {
				continue
			}
			fieldName := toGoCase(f.GetName())
			if f.GetType() == FieldDescriptorProto_TYPE_MESSAGE {
				fieldType := f.GetTypeName()
				if idx := strings.LastIndex(fieldType, `.`); idx != -1 {
					fieldType = fieldType[idx+1:]
				}
				if f.GetLabel() == FieldDescriptorProto_LABEL_REPEATED {
					itName := m.GetName() + fieldType + "Iterator"

					st.Write(indent, "type ", itName, " []byte\n\n")

					st.Write(indent, "func (i *", itName, ") Next(m *", fieldType, ") (bool, error) {\n")
					st.Write(indent.Next(), "var buf []byte\n")
					st.Write(indent.Next(), "*i, buf = zeropb.FindNextField((*i), ", f.GetNumber(), ")\n")
					st.Write(indent.Next(), "if buf == nil {\n")
					st.Write(indent.Next().Next(), "return false, nil\n")
					st.Write(indent.Next(), "}\n")
					st.Write(indent.Next(), "return true, m.Decode(buf)\n")
					st.Write(indent, "}\n\n")

					st.Write(indent, "func (m *", m.GetName(), ") ", fieldName, "() ", itName, " {\n")
					st.Write(indent.Next(), "return ", itName, "(zeropb.GetRepeatedMessage(m.buf, &m.offsets, ", f.GetNumber(), "))\n")
					st.Write(indent, "}\n\n")
				} else {
					st.Write(indent, "func (m *", m.GetName(), ") ", fieldName, "(x *", fieldType, ") (bool, error) {\n")
					st.Write(indent.Next(), "buf := zeropb.GetBytes(m.buf, &m.offsets, ", f.GetNumber(), ")\n")
					st.Write(indent.Next(), "if buf == nil {\n")
					st.Write(indent.Next().Next(), "return false, nil\n")
					st.Write(indent.Next(), "}\n")
					st.Write(indent.Next(), "return true, x.Decode(buf)\n")
					st.Write(indent, "}\n\n")
				}
			} else {
				if f.GetLabel() == FieldDescriptorProto_LABEL_REPEATED {
					// WIP
					continue
				}
				fieldType, fieldFnName := toGoType(f.GetType(), f.GetTypeName())
				if fieldType == `` {
					// WIP remove this when all field types are implemented
					continue
				}
				st.Write(indent, "func (m *", m.GetName(), ") ", fieldName, "() ", fieldType, " {\n")
				st.Write(indent.Next(), "return zeropb.Get", fieldFnName, "(m.buf, &m.offsets, ", f.GetNumber(), ")\n")
				st.Write(indent, "}\n\n")
			}
		}
	}

	name := strings.ReplaceAll(req.GetName(), `.proto`, `.zeropb.go`)
	content := buf.String()
	res := &CodeGeneratorResponse_File{Name: &name, Content: &content}
	return res, nil
}

func toGoCase(s string) string {
	titleNext := true
	mapFn := func(r rune) rune {
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) {
			titleNext = true
			return -1
		}
		if titleNext {
			titleNext = false
			return unicode.ToTitle(r)
		}
		return r
	}
	return strings.Map(mapFn, s)
}

func toGoType(typ FieldDescriptorProto_Type, typName string) (string, string) {
	switch typ {
	case FieldDescriptorProto_TYPE_UINT64:
		return `uint64`, `Uint64`
	case FieldDescriptorProto_TYPE_BYTES:
		return `[]byte`, `Bytes`
	case FieldDescriptorProto_TYPE_ENUM:
		return `uint32`, `Uint32`
	}
	// WIP implement the rest of these
	return ``, ``
}
